FORMAT: 1A

# Consul HTTP API

The main interface to Consul is a RESTful HTTP API. The API can be used for CRUD
for nodes, services, checks, and configuration. The endpoints are versioned to
enable changes without breaking backwards compatibility.

## Blocking Queries

Certain endpoints support a feature called a "blocking query." A blocking query
is used to wait for a change to potentially take place using long polling.

Queries that support this will mention it specifically, however the use of this
feature is the same for all. If supported, the query will set an HTTP header `X
-Consul-Index`. This is an opaque handle that the client will use.

To cause a query to block, the query parameters `?wait=<interval>&index=<idx>`
are added to a request. The `wait` query parameter limits how long the query
will potentially block for. If not set, it will default to 10 minutes. It can be
specified in the form of "10s" or "5m", which is 10 seconds or 5 minutes
respectively. The `index` parameter is an opaque handle, which is used by Consul
to detect changes. The `X-Consul-Index` header for a query provides this value,
and can be used to wait for changes since the query was run.

When provided, Consul blocks sending a response until there is an update that
could have cause the output to change, and thus advancing the index. A critical
note is that when the query returns there is **no guarantee** of a change. It is
possible that the timeout was reached, or that there was an idempotent write
that does not affect the result.

## Consistency Modes

Most of the read query endpoints support multiple levels of consistency. These
are to provide a tuning knob that clients can be used to find a happy medium
that best matches their needs.

The three read modes are:

* default - If not specified, this mode is used. It is strongly consistent in
almost all cases. However, there is a small window in which an new leader may be
elected, and the old leader may service stale values. The trade off is fast
reads, but potentially stale values. This condition is hard to trigger, and most
clients should not need to worry about the stale read. This only applies to
reads, and a split-brain is not possible on writes.

* consistent - This mode is strongly consistent without caveats. It requires that
a leader verify with a quorum of peers that it is still leader. This introduces
an additional round-trip to all server nodes. The trade off is always consistent
reads, but increased latency due to an extra round trip. Most clients should not
use this unless they cannot tolerate a stale read.

* stale - This mode allows any server to service the read, regardless of if it is
the leader. This means reads can be arbitrarily stale, but are generally within
50 milliseconds of the leader. The trade off is very fast and scalable reads but
values will be stale. This mode allows reads without a leader, meaning a cluster
that is unavailable will still be able to respond.

To switch these modes, either the `stale` or `consistent` query parameters are
provided. It is an error to provide both.

To support bounding how stale data is, there is an `X-Consul-LastContact` which
is the last time a server was contacted by the leader node in milliseconds. The
`X-Consul-KnownLeader` also indicates if there is a known leader. These can be
used to gauge if a stale read should be used.

## Formatted JSON Output

By default, the output of all HTTP API requests return minimized JSON with all
whitespace removed. By passing the `pretty` query parameter, formatted JSON will
be returned.

## ACLs

Several endpoints in Consul use or require ACL tokens to operate. An agent can
be configured to use a default token in requests using the `acl_token`
configuration option. However, the token can also be specified per-request by
using the `token` query parameter. This will take precedence over the default
token.

# Group KV

## Key/Value store [/v1/kv/{+key}{?dc,wait,index,token,keys,recurse,separator,stale,consistent,pretty,raw,flags,cas,acquire,release}]

The KV endpoint is used to expose a simple **key/value store**.  This can be
used to store service configurations or other meta data in a simple way.  It has
only a single endpoint: `/v1/kv/<key>`.

By default the datacenter of the agent is queried, however the dc can be
provided using the `dc` query parameter. If a client wants to write to all
Datacenters, one request per datacenter must be made.

The KV endpoint supports the use of ACL tokens.

+ Parameters
    + dc (optional, string) ... datacenter
    + key (optional, path) ... the key
    + token (optional, string) ... per-request ACL token

### Retrieve key [GET]

Retrieve the specified key, or if `recurse` is provided, return all keys with
the given prefix.  If `keys` is provided, return a list of the keys under the
given prefix; used with `separator`, list only up to a given separator.

A blocking query can be used to wait for a value to change.

If `recurse` is used, the `X-Consul-Index` corresponds to the latest
`ModifyIndex` and so a blocking query waits until any of the listed keys are
updated.

This endpoint supports blocking queries and all consistency modes.

#### Response Payload

- `CreateIndex` - internal index value that represents when the entry was created
- `ModifyIndex` - last index that modified this key; corresponds to the `X-Consul-Index` header value
- `LockIndex`   - last index of a successful lock acquisition
- `Key`         - full path of the entry
- `Flags`       - opaque unsigned integer that can be attached to each entry; use of this is left totally to the user
- `Session`     - key provides the session that owns the lock
- `Value`       - a base64 key value

+ Parameters
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + recurse (optional)                ... return all keys with the given prefix
    + keys (optional)                   ... return a list of the keys under the given prefix
    + separator (optional, string)      ... with `keys`, list only up to a given separator
    + raw (optional)                    ... with non-recursive get, response is raw value of key, without encoding
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode
    + pretty (optional)                 ... if provided, formatted JSON is returned

+ Request single-key

+ Response 200 (application/json)
    + Headers
        
            X-Consul-Index: <handle>
            X-Consul-LastContact: last time a server was contacted (ms)
            X-Consul-KnownLeader: boolean if there is a known leader

    + Body

            [
                {
                    "CreateIndex": 100,
                    "ModifyIndex": 200,
                    "LockIndex": 200,
                    "Key": "zip",
                    "Flags": 0,
                    "Value": "dGVzdA==",
                    "Session": "adf4238a-882b-9ddc-4a9d-5b6758e4159e"
                }
            ]

+ Response 404

+ Request list-keys

+ Response 200 (application/json)

    + Body
    
            @todo

### Create or Update Key [PUT]

The return value is simply either `true` or `false`.
If `false` is returned, then the update has not taken place.

Complex locking and synchronization operations are possbile.

#### Check-And-Set

Clients may build more complex synchronization primives using the Check-And-Set
operation with the `cas` parameter.

If the `cas` value is `0`, Consul will only create the key if it does not already exist.
If the `cas` value is non-zero, then the key is only updated if the index
matches the `ModifyIndex` for the key.

#### Locking

Locking is a useful feature that allows leader election to be built on top of
Consul.

Acquire a lock by providing the `acquire` parameter with a valid session ID. If
the lock is not held, this increments the `LockIndex` and sets the `Session`
value of the key in addition to updating the key contents. A key does not need
to exist to be acquired.

Yield a lock by providing the `release` parameter with the ID of the session
holding the lock.Â  This will leave the `LockIndex` unmodified but will clear the
associated `Session` of the key. The key must be held by this session to be
unlocked.

+ Parameters
    + flags (optional, num) ... an unsigned value between 0 and 2^64-1
    
        Opaque to the user, but client applications may use it.

    + cas (optional, num) ... performs a Check-And-Set operation
    + acquire (optional, session) ... performs a lock acquisition operation
    + release (optional, session) ... performs a lock release operation


+ Request

        value of key

+ Response 200 (application/json)

        true

### Delete a Key [DELETE]

Delete a single key or all keys sharing a prefix.

If the `recurse` parameter is provided, then all keys with the prefix are
deleted, otherwise only the specified key.

+ Parameters
    + recurse (optional) ... all keys with the prefix are deleted

+ Response 200

# Group Agent control

The Agent endpoints are used to interact with a local Consul agent.  Usually,
services and checks are registered with an agent, which then takes on the burden
of registering with the Catalog and performing anti-entropy to recover from
outages.  There are also various control APIs that can be used instead of the
msgpack RPC protocol.

## Checks [/v1/agent/checks]

### Return the checks the local agent is managing [GET]

This endpoint is used to return the all the checks that are registered with the
local agent.  These checks were either provided through configuration files, or
added dynamically using the HTTP API.  It is important to note that the checks
known by the agent may be different than those reported by the Catalog. This is
usually due to changes being made while there is no leader elected.  The agent
performs active anti-entropy, so in most situations everything will be in sync
within a few seconds.

+ Response 200 (application/json)

    + Body
    
            {
                "service:redis": {
                    "Node": "foobar",
                    "CheckID": "service:redis",
                    "Name": "Service 'redis' check",
                    "Status": "passing",
                    "Notes": "",
                    "Output": "",
                    "ServiceID": "redis",
                    "ServiceName": "redis"
                }
            }

## Services [/v1/agent/services]

### Return the services local agent is managing [GET]

This endpoint is used to return the all the services that are registered with
the local agent.  These services were either provided through configuration
files, or added dynamically using the HTTP API.  It is important to note that
the services known by the agent may be different than those reported by the
Catalog.  This is usually due to changes being made while there is no leader
elected.  The agent performs active anti-entropy, so in most situations
everything will be in sync within a few seconds.

+ Response 200 (application/json)

    + Body

            {
                "redis": {
                    "ID": "redis",
                    "Service": "redis",
                    "Tags": null,
                    "Port": 8000
                }
            }


## Members [/v1/agent/members{?wan}]

### Return the members as seen by the local serf agent [GET]

This endpoint returns the members the agent sees in the cluster gossip pool.
Due to the nature of gossip, this is eventually consistent and the results may
differ by agent.  The strongly consistent view of nodes is instead provided by
`/v1/catalog/nodes` (@todo link).

For agents running in server mode, providing `wan=1` returns the list of WAN
members instead of the LAN members which is default.

+ Parameters
    + wan (optional, num) ... `1` returns list of WAN instead of LAN members

+ Response 200 (application/json)

    + Body

            [
                {
                    "Name": "foobar",
                    "Addr": "10.1.10.12",
                    "Port": 8301,
                    "Tags": {
                        "bootstrap": "1",
                        "dc": "dc1",
                        "port": "8300",
                        "role": "consul"
                    },
                    "Status": 1,
                    "ProtocolMin": 1,
                    "ProtocolMax": 2,
                    "ProtocolCur": 2,
                    "DelegateMin": 1,
                    "DelegateMax": 3,
                    "DelegateCur": 3
                }
            ]

## Self [/v1/agent/self]

### Return the local node configuration [GET]

This endpoint is used to return configuration of the local agent and member information.

+ Response 200 (application/json)

    + Body
    
            {
                "Config": {
                    "Bootstrap": true,
                    "Server": true,
                    "Datacenter": "dc1",
                    "DataDir": "/tmp/consul",
                    "DNSRecursor": "",
                    "Domain": "consul.",
                    "LogLevel": "INFO",
                    "NodeName": "foobar",
                    "ClientAddr": "127.0.0.1",
                    "BindAddr": "0.0.0.0",
                    "AdvertiseAddr": "10.1.10.12",
                    "Ports": {
                        "DNS": 8600,
                        "HTTP": 8500,
                        "RPC": 8400,
                        "SerfLan": 8301,
                        "SerfWan": 8302,
                        "Server": 8300
                    },
                    "LeaveOnTerm": false,
                    "SkipLeaveOnInt": false,
                    "StatsiteAddr": "",
                    "Protocol": 1,
                    "EnableDebug": false,
                    "VerifyIncoming": false,
                    "VerifyOutgoing": false,
                    "CAFile": "",
                    "CertFile": "",
                    "KeyFile": "",
                    "StartJoin": [],
                    "UiDir": "",
                    "PidFile": "",
                    "EnableSyslog": false,
                    "RejoinAfterLeave": false
                },
                "Member": {
                    "Name": "foobar",
                    "Addr": "10.1.10.12",
                    "Port": 8301,
                    "Tags": {
                        "bootstrap": "1",
                        "dc": "dc1",
                        "port": "8300",
                        "role": "consul",
                        "vsn": "1",
                        "vsn_max": "1",
                        "vsn_min": "1"
                    },
                    "Status": 1,
                    "ProtocolMin": 1,
                    "ProtocolMax": 2,
                    "ProtocolCur": 2,
                    "DelegateMin": 2,
                    "DelegateMax": 4,
                    "DelegateCur": 4
                }
            }

## Join [/v1/agent/join/{address}{?wan}]

### Trigger local agent to join a node [GET]

This endpoint is used to instruct the agent to attempt to connect to a given
address. For agents running in server mode, providing `wan=1` causes the agent
to attempt to join using the WAN pool.

+ Parameters
    + address (required, string) ... address of node to join
    + wan (optional, num) ... `1` joins the WAN instead of the LAN pool

+ Response 200

## Force Leave [/v1/agent/force-leave/{node}]

### Force remove node [GET]

This endpoint is used to instructs the agent to force a node into the left
state.  If a node fails unexpectedly, then it will be in a "failed" state.  Once
in this state, Consul will attempt to reconnect, and additionally the services
and checks belonging to that node will not be cleaned up. Forcing a node into
the left state allows its old entries to be removed.

+ Parameters
    + node (required, string) ... the node to remove

+ Response 200

## Register Check [/v1/agent/check/register]

### Register a new local check [PUT]

The register endpoint is used to add a new check to the local agent.  There is
more documentation on checks [here](/docs/agent/checks.html). Checks are either
a script or TTL type. The agent is responsible for managing the status of the
check and keeping the Catalog in sync.

The `Name` field is mandatory, as is either `Script` and `Interval` or `TTL`.
Only one of `Script` and `Interval` or `TTL` should be provided. If an `ID` is
not provided, it is set to `Name`. You cannot have duplicate `ID` entries per
agent, so it may be necessary to provide an `ID`. The `Notes` field is not used
by Consul, and is meant to be human readable.

If a `Script` is provided, the check type is a script, and Consul will evaluate
the script every `Interval` to update the status. If a `TTL` type is used, then
the TTL update APIs must be used to periodically update the state of the check.

+ Request
    
        {
            "ID": "mem",
            "Name": "Memory utilization",
            "Notes": "Ensure we don't oversubscribe memory",
            "Script": "/usr/local/bin/check_mem.py",
            "Interval": "10s",
            "TTL": "15s"
        }

+ Response 200

## Deregister Check [/v1/agent/check/deregister/{checkID}]

### Deregister a local check [GET]

Remove a check from the local agent.  The agent will take care of deregistering
the check with the Catalog.

+ Response 200

## Set Check Status [/v1/agent/check/{state}/{checkID}{?note}]

### Set status of local test [GET]

This endpoint is used with [TTL type](/docs/agent/checks.html) checks. Sets the
check status and resets the TTL clock.

* state `pass` sets `checkID` to status `passing`
* state `warn` sets `checkID` to status `warning`
* state `fail` sets `checkID` to status `critical`

+ Parameters
    + state (required, enum) ... the state of the check
        + Values
            + `pass`
            + `warn`
            + `fail`
    + checkID (required, string) ... the ID of the check
    + note (optional, string) ... check output
    
        Should be human-readable for operators

+ Response 200

## Register Service [/v1/agent/service/register]

### Registers a new local service [PUT]

The register endpoint is used to add a new service to the local agent.  There is
more documentation on services [here](/docs/agent/services.html). Services may
also provide a health check. The agent is responsible for managing the status of
the check and keeping the Catalog in sync.

The `Name` field is mandatory.  If an `ID` is not provided, it is set to `Name`.
You cannot have duplicate `ID` entries per agent, so it may be necessary to
provide an `ID`. `Tags`, `Port` and `Check` are optional. If `Check` is
provided, only one of `Script` and `Interval` or `TTL` should be provided. There
is more information about checks [here](/docs/agent/checks.html).

The created check will be named `service:<ServiceId>`.


+ Request

        {
            "ID": "redis1",
            "Name": "redis",
            "Tags": [ "master", "v1" ],
            "Port": 8000,
            "Check": {
                "Script": "/usr/local/bin/check_redis.py",
                "Interval": "10s",
                "TTL": "15s"
            }
        }

+ Response 200

## Deregister Service [/v1/agent/service/deregister/{serviceID}]

### Deregister a local service [GET]

Removes a service from the local agent. The agent will take care of
deregistering the service with the Catalog. If there is an associated check,
that is also deregistered.

+ Parameters
    + serviceID (required, string) ... ID of service to deregister

+ Response 200

# Group Catalog

The Catalog is the endpoint used to register and deregister nodes, services, and
checks. It also provides a number of query endpoints.

## Register [/v1/catalog/register]

### Registers a new node, service, or check [PUT]

Low level mechanism for directly registering or updating entries in the catalog.
It is usually recommended to use the agent local endpoints, as they are simpler
and perform anti-entropy.

The behavior of the endpoint depends on what keys are provided. 

The endpoint requires `Node` and `Address` to be provided, while `Datacenter`
will be defaulted to match that of the agent. If only those are provided, the
endpoint will register the node with the catalog.

If the `Service` key is provided, then the service will also be registered. If
`ID` is not provided, it will be defaulted to `Service`. It is mandated that the
`ID` be node-unique. Both `Tags` and `Port` can be omitted.

If the `Check` key is provided, then a health check will also be registered. It
is important to remember that this register API is very low level. This
manipulates the health check entry, but does not setup a script or TTL to
actually update the status. For that behavior, an agent local check should be
setup.

The `CheckID` can be omitted, and will default to the `Name`. Like before, the
`CheckID` must be node-unique. `Notes` is an opaque field that is meant to hold
human readable text. If a `ServiceID` is provided that matches the `ID` of a service
on that node, then the check is treated as a service level health check, instead
of a node level health check. Lastly, the `Status` must be one of `unknown`,
`passing`, `warning`, or `critical`. The `unknown` status is used to indicate
that the initial check has not been performed yet.

It is important to note that `Check` does not have to be provided with `Service`
and visa-versa. They can be provided or omitted at will.

+ Request

        {
            "Datacenter": "dc1",
            "Node": "foobar",
            "Address": "192.168.10.10",
            "Service": {
                "ID": "redis1",
                "Service": "redis",
                "Tags": [
                    "master",
                    "v1"
                ],
                "Port": 8000
            },
            "Check": {
                "Node": "foobar",
                "CheckID": "service:redis1",
                "Name": "Redis health check",
                "Notes": "Script based health check",
                "Status": "passing",
                "ServiceID": "redis1"
            }
        }

+ Response 200


## Deregister [/v1/catalog/deregister]

### Deregisters a node, service, or check [PUT]

Low level mechanism for directly removing entries in the catalog. It is usually
recommended to use the agent local endpoints, as they are simpler and perform
anti-entropy.

+ Request node

        {
            "Datacenter": "dc1",
            "Node": "foobar"
        }

+ Response 200

+ Request check

        {
            "Datacenter": "dc1",
            "Node": "foobar",
            "CheckID": "service:redis1"
        }

+ Response 200

+ Request service

        {
            "Datacenter": "dc1",
            "Node": "foobar",
            "ServiceID": "redis1"
        }

+ Response 200

## Datacenters [/v1/catalog/datacenters]

### Lists known datacenters [GET]

Return all the datacenters that are known by the Consul server.

This endpoint does not require a cluster leader, and as such will succeed even
during an availability outage. It can thus be a simple check to see if any
Consul servers are routable.

+ Response 200 (application/json)
    + Body

            ["dc1", "dc2"]

## Nodes [/v1/catalog/nodes{?dc,wait,index,stale,consistent}]

### Lists nodes in a given DC [GET]

Returns the nodes known about in a given datacenter.

Supports blocking queries and all consistency modes.

+ Parameters
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)
    + Headers
    
            X-Consul-Index: 20116425
            X-Consul-Knownleader: true
            X-Consul-Lastcontact: 0

    + Body
    
            [
                {
                    "Node": "baz",
                    "Address": "10.1.10.11"
                },
                {
                    "Node": "foobar",
                    "Address": "10.1.10.12"
                }
            ]

## Services [/v1/catalog/services{?dc,wait,index,stale,consistent}]

### Lists services in a given DC [GET]

Returns the services known about in a given datacenter.

The main object keys are the service names, while the array provides all the
known tags for a given service.

Supports blocking queries and all consistency modes.

+ Parameters
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)
    + Headers
    
            X-Consul-Index: 20116205
            X-Consul-Knownleader: true
            X-Consul-Lastcontact: 0

    + Body
    
            {
                "consul": [],
                "redis": [],
                "postgresql": [
                    "master",
                    "slave"
                ]
            }

## Nodes for Service [/v1/catalog/service/<service>{?tag,dc,wait,index,stale,consistent}]

### Lists the nodes in a given service [GET]

Returns the nodes providing a service in a given datacenter.  By default all
nodes in that service are returned. However, the list can be filtered by tag
using the `tag` query parameter.

Supports blocking queries and all consistency modes.

+ Parameters
    + tag (optional, string)            ... tag to filter on
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)
    + Headers
    
            X-Consul-Index: 20116444
            X-Consul-Knownleader: true
            X-Consul-Lastcontact: 0

    + Body

            [
                {
                    "Node": "foobar",
                    "Address": "10.1.10.12",
                    "ServiceID": "redis",
                    "ServiceName": "redis",
                    "ServiceTags": null,
                    "ServicePort": 8000
                }
            ]

## Services for Node [/v1/catalog/node/<node>{?dc,wait,index,stale,consistent}]

### Lists the services provided by a node [GET]

Returns the node-provided services.

Supports blocking queries and all consistency modes.

+ Parameters
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)
    + Headers
        
            X-Consul-Index: 20116455
            X-Consul-Knownleader: true
            X-Consul-Lastcontact: 0

    + Body

            {
                "Node": {
                    "Node": "foobar",
                    "Address": "10.1.10.12"
                },
                "Services": {
                    "consul": {
                        "ID": "consul",
                        "Service": "consul",
                        "Tags": null,
                        "Port": 8300
                    },
                    "redis": {
                        "ID": "redis",
                        "Service": "redis",
                        "Tags": [
                            "v1"
                        ],
                        "Port": 8000
                    }
                }
            }

# Group Health

The Health endpoints are used to query health related information. It is
provided separately from the Catalog, since users may prefer to not use the
health checking mechanisms as they are totally optional. Additionally, some of
the query results from the Health system are filtered, while the Catalog
endpoints provide the raw entries.

## Node [/v1/health/node/{node}{?dc,index,wait,stale,consistent}]

### Returns the health info of a node [GET]

Returns the node specific checks known.

In the sample response body, we can see there is a system level check (no
associated `ServiceID`, as well as a service check for Redis). The "serfHealth"
check is special, in that all nodes automatically have this check. When a node
joins the Consul cluster, it is part of a distributed failure detection provided
by Serf. If a node fails, it is detected and the status is automatically changed
to "critical".

+ Parameters
    + node (required, string)
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)
    + Headers
    
            X-Consul-Index: 20116461
            X-Consul-Knownleader: true
            X-Consul-Lastcontact: 0

    + Body

            [
                {
                    "Node": "foobar",
                    "CheckID": "serfHealth",
                    "Name": "Serf Health Status",
                    "Status": "passing",
                    "Notes": "",
                    "Output": "",
                    "ServiceID": "",
                    "ServiceName": ""
                },
                {
                    "Node": "foobar",
                    "CheckID": "service:redis",
                    "Name": "Service 'redis' check",
                    "Status": "passing",
                    "Notes": "",
                    "Output": "",
                    "ServiceID": "redis",
                    "ServiceName": "redis"
                }
            ]

## Checks [/v1/health/checks/{service}{?dc,index,wait,stale,consistent}]

### Returns the checks of a service [GET]

Returns the checks associated with a service.

+ Parameters
    + service (required, string)
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)
    + Headers
        
            X-Consul-Index: 20116464
            X-Consul-Knownleader: true
            X-Consul-Lastcontact: 0

    + Body
    
            [
                {
                    "Node": "foobar",
                    "CheckID": "service:redis",
                    "Name": "Service 'redis' check",
                    "Status": "passing",
                    "Notes": "",
                    "Output": "",
                    "ServiceID": "redis",
                    "ServiceName": "redis"
                }
            ]

## Service [/v1/health/service/{service}{?dc,index,wait,stale,consistent,tag,passing}]

### Returns the nodes and health info of a service [GET]

Returns the service nodes providing a given service.

By default all nodes in that service are returned.  However, the list can be
filtered by tag using the `tag` query parameter.

This is very similar to the `/v1/catalog/service endpoint`, however this
endpoint automatically returns the status of the associated health check, as
well as any system level health checks. This allows a client to avoid sending
traffic to nodes failing health tests, or who are reporting warnings.

Providing the `passing` query parameter will filter results to only nodes with
all checks in the passing state. This can be used to avoid some filtering logic
on the client side. (Added in Consul 0.2)

Users can also built in support for dynamic load balancing and other features by
incorporating the use of health checks.

+ Parameters
    + service (required, string)
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode
    + tag (optional, string)            ... tag to filter on
    + passing (optional)                ... if provided, return only passing nodes

+ Response 200 (application/json)
    + Headers
    
            X-Consul-Index: 20116478
            X-Consul-Knownleader: true
            X-Consul-Lastcontact: 0

    + Body
    
            [
                {
                    "Node": {
                        "Node": "foobar",
                        "Address": "10.1.10.12"
                    },
                    "Service": {
                        "ID": "redis",
                        "Service": "redis",
                        "Tags": null,
                        "Port": 8000
                    },
                    "Checks": [
                        {
                            "Node": "foobar",
                            "CheckID": "service:redis",
                            "Name": "Service 'redis' check",
                            "Status": "passing",
                            "Notes": "",
                            "Output": "",
                            "ServiceID": "redis",
                            "ServiceName": "redis"
                        },
                        {
                            "Node": "foobar",
                            "CheckID": "serfHealth",
                            "Name": "Serf Health Status",
                            "Status": "passing",
                            "Notes": "",
                            "Output": "",
                            "ServiceID": "",
                            "ServiceName": ""
                        }
                    ]
                }
            ]

## State [/v1/health/state/{state}{?dc,index,wait,stale,consistent}]

### Returns the checks in a given state [GET]

Returns the checks in a specific state.

The state being queried must be provided after the slash. The supported states
are "any", "unknown", "passing", "warning", or "critical". The "any" state is a
wildcard that can be used to return all the checks.

+ Parameters
    + state (required, enum)
        + Values
            + `any`
            + `unknown`
            + `passing`
            + `warning`
            + `critical`
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)
    + Headers
        
            X-Consul-Index: 20116483
            X-Consul-Knownleader: true
            X-Consul-Lastcontact: 0

    + Body
    
            [
                {
                    "Node": "foobar",
                    "CheckID": "serfHealth",
                    "Name": "Serf Health Status",
                    "Status": "passing",
                    "Notes": "",
                    "Output": "",
                    "ServiceID": "",
                    "ServiceName": ""
                },
                {
                    "Node": "foobar",
                    "CheckID": "service:redis",
                    "Name": "Service 'redis' check",
                    "Status": "passing",
                    "Notes": "",
                    "Output": "",
                    "ServiceID": "redis",
                    "ServiceName": "redis"
                }
            ]

# Group Session

The Session endpoints are used to create, destroy and query sessions.

## Create [/v1/session/create{?dc}]

### Creates a new session [PUT]

Initialize a new session. There is more documentation on sessions
[here](/docs/internals/sessions.html).  Sessions must be associated with a node,
and optionally any number of checks. By default, the agent uses its own node
name, and provides the "serfHealth" check, along with a 15 second lock delay.

By default, the agent's local datacenter is used, but another datacenter can be
specified using the `dc` query parameter. It is not recommended to use cross-
region sessions.

None of the fields are mandatory, and in fact no request body is required if the
defaults are to be used. The `LockDelay` field can be specified as a duration
string using a "s" suffix for seconds. It can also be a numeric value. Small
values are treated as seconds, and otherwise it is provided with nanosecond
granularity.

The `Node` field must refer to a node that is already registered. By default,
the agent will use its own name. The `Name` field can be used to provide a human
readable name for the Session. Lastly, the `Checks` field is used to provide a
list of associated health checks. By default the "serfHealth" check is provided.
It is highly recommended that if you override this list, you include that check.

The response contains the ID of the newly-created session.

+ Parameters
    + dc (optional, string) ... datacenter to query; defaults to agent's datacenter

+ Request

        {
            "LockDelay": "15s",
            "Name": "my-service-lock",
            "Node": "foobar",
            "Checks": ["a", "b", "c"]
        }

+ Response 200 (application/json)
    + Body
    
            {
                "ID": "adf4238a-882b-9ddc-4a9d-5b6758e4159e"
            }

## Destroy [/v1/session/destroy/{session}{?dc}]

### Destroys a given session [PUT]

Destroys the given session.

+ Parameters
    + session (required, string) ... session ID to destroy
    + dc (optional, string)      ... datacenter to query; defaults to agent's datacenter

+ Response 200 (application/json)
    + Body

            true

## Info [/v1/session/info/{session}{?dc,index,wait,stale,consistent}]

### Queries a given session [GET]

Returns the session information by ID.

If the session is not found, `null` is returned instead of a JSON list.

This endpoint supports blocking queries and all consistency modes.

+ Parameters
    + session (required, string)        ... session ID to query
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)
    + Headers
    
            X-Consul-Index: 20116517
            X-Consul-Knownleader: true
            X-Consul-Lastcontact: 0

    + Body

            [
                {
                    "LockDelay": 1.5E+10,
                    "Checks": [
                        "serfHealth"
                    ],
                    "Node": "foobar",
                    "ID": "adf4238a-882b-9ddc-4a9d-5b6758e4159e",
                    "CreateIndex": 1086449
                }
            ]

## Sessions for Node [/v1/session/node/{node}{?dc,index,wait,stale,consistent}]

### Lists sessions belonging to a node [GET]

Returns the active sessions for a given node.

This endpoint supports blocking queries and all consistency modes.

+ Parameters
    + node (required, string)
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)
    + Headers
    
            X-Consul-Index: 20116517
            X-Consul-Knownleader: true
            X-Consul-Lastcontact: 0

    + Body

            [
                {
                    "LockDelay": 1.5E+10,
                    "Checks": [
                        "serfHealth"
                    ],
                    "Node": "foobar",
                    "ID": "adf4238a-882b-9ddc-4a9d-5b6758e4159e",
                    "CreateIndex": 1086449
                },
                ...
            ]

## List [/v1/session/list{?dc,index,wait,stale,consistent}]

### Lists all the active sessions [GET]

Returns the active sessions for a given datacenter.

This endpoint supports blocking queries and all consistency modes.

+ Parameters
    + dc (optional, string)             ... datacenter to query; defaults to agent's datacenter
    + index (optional, handle)          ... initiates a blocking query
    + wait = `10m` (optional, interval) ... limits how long query will potentially block for; use with `index`
    + consistent (optional)             ... consistent read mode
    + stale (optional)                  ... stale read mode

+ Response 200 (application/json)
    + Headers
        
            X-Consul-Index: 20116517
            X-Consul-Knownleader: true
            X-Consul-Lastcontact: 0

    + Body

            [
                {
                    "LockDelay": 1.5E+10,
                    "Checks": [
                        "serfHealth"
                    ],
                    "Node": "foobar",
                    "ID": "adf4238a-882b-9ddc-4a9d-5b6758e4159e",
                    "CreateIndex": 1086449
                },
                ...
            ]

# Group ACL

The ACL endpoints are used to create, update, destroy and query ACL tokens.

In any Consul cluster, only a single datacenter is authoritative for ACLs, so
all requests are automatically routed to that datacenter regardless of the agent
that the request is made to.

## Create [/v1/acl/create{?token}]

### Creates a new token with policy [PUT]

The create endpoint is used to make a new token. A token has a name, type, and a
set of ACL rules. The name is opaque to Consul, and type is either "client" or
"management". A management token is effectively like a root user, and has the
ability to perform any action including creating, modifying, and deleting ACLs.
A client token can only perform actions as permitted by the rules associated,
and may never manage ACLs. This means the request to this endpoint must be made
with a management token.

None of the fields are mandatory, and in fact no body needs to be provided if
the defaults are to be used. The `Name` and `Rules` default to being blank, and
the `Type` defaults to "client". The format of `Rules` is [documented
here](/docs/internals/acl.html).

The response contains the ID of the newly-created ACL token.

+ Parameters
    + token (required, string) ... ACL token

+ Request

        {
            "Name": "my-app-token",
            "Type": "client",
            "Rules": ""
        }

+ Response 200 (application/json)
    + Body
    
            {
                "ID": "adf4238a-882b-9ddc-4a9d-5b6758e4159e"
            }

+ Response 401 (text/plain)
    + Body

            ACL support disabled

## Update [/v1/acl/update{?token}]

### Update the policy of a token [PUT]

The update endpoint is used to modify the policy for a given ACL token. It is
very similar to the create endpoint, however instead of generating a new token
ID, the ID field must be provided. Requests to this endpoint must be made with a
management token.

Only the `ID` field is mandatory, the other fields provide defaults. The `Name`
and `Rules` default to being blank, and the `Type` defaults to "client". The
format of Rules is The format of `Rules` is [documented
here](/docs/internals/acl.html).

+ Parameters
    + token (required, string) ... ACL token

+ Request

        {
            "ID": "adf4238a-882b-9ddc-4a9d-5b6758e4159e",
            "Name": "my-app-token-updated",
            "Type": "client",
            "Rules": "# New Rules"
        }

+ Response 200

## Destroy [/v1/acl/destroy/{id}{?token}]

### Destroys a given token [PUT]

Destroys the given ACL token.  Requests to the endpoint must be made with a
management token.

+ Parameters
    + id (required, string) ... ACL token id to destroy
    + token (required, string) ... ACL token

+ Response 200

## Query [/v1/acl/info/{id}]

### Queries the policy of a given token [GET]

Returns the token information by ID.

If the session is not found, `null` is returned instead of a JSON list.

+ Parameters
    + id (required, string) ... ACL token id to retrieve

+ Response 200
    + Body
            
            [
                {
                    "CreateIndex": 3,
                    "ModifyIndex": 3,
                    "ID": "8f246b77-f3e1-ff88-5b48-8ec93abf3e05",
                    "Name": "Client Token",
                    "Type": "client",
                    "Rules": "..."
                }
            ]

## Clone [/v1/acl/clone/{id}{?token}]

### Creates a new token by cloning an existing token [GET]

Returns a token ID that is cloned from an existing token. This allows a token to
serve as a template for others, making it simple to generate new tokens without
complex rule management.  Requests to this endpoint require a management token.

The response contains the ID of the newly-created ACL token.

+ Parameters
    + id (required, string) ... Source ACL token id
    + token (required, string) ... ACL token

+ Response 200
    + Body
            
            {
                "ID": "adf4238a-882b-9ddc-4a9d-5b6758e4159e"
            }

## List [/v1/acl/list{?token}]

### Lists all the active tokens [GET]

Lists all the active ACL tokens. This is a privileged endpoint, and requires a
management token.

+ Parameters
    + token (required, string) ... ACL token

+ Response 200 (application/json)
    + Body
            
            [
                {
                    "CreateIndex": 3,
                    "ModifyIndex": 3,
                    "ID": "8f246b77-f3e1-ff88-5b48-8ec93abf3e05",
                    "Name": "Client Token",
                    "Type": "client",
                    "Rules": "..."
                },
                ...
            ]

# Group Events

The Event endpoints are used to fire new events and to query the available
events.

## Fire [/v1/event/fire/{name}{?node,service,tag}]

### Fires a new user event [PUT]

The fire endpoint is used to trigger a new user event. A user event needs a
`name`, and optionally takes a number of parameters.

The endpoint takes an optional body. The body contents are opaque to Consul, and
become the "payload" of the event. Any names starting with the "_" prefix should
be considered reserved, and for Consul's internal use.

The `node`, `service`, and `tag` query parameters may optionally be provided.
They respectively provide a regular expression to filter by node name, service,
and service tags.

The response contains the ID of the newly-fired event.

+ Parameters
    + node (optional, regex)
    + service (optional, regex)
    + tag (optional, regex)

+ Response 200 (application/json)
    + Body
        
            {
                "ID": "b54fe110-7af5-cafc-d1fb-afc8ba432b1c",
                "Name": "deploy",
                "Payload": null,
                "NodeFilter": "",
                "ServiceFilter": "",
                "TagFilter": "",
                "Version": 1,
                "LTime": 0
            }

## List [/v1/event/list{?name}]

### Lists the most recent events an agent has seen. [GET]

This endpoint is hit with a GET and returns the most recent events known by the
agent. As a consequence of how the [event command](/docs/commands/event.html)
works, each agent may have a different view of the events. Events are broadcast
using the [gossip protocol](/docs/internals/gossip.html), which means they have
no total ordering, nor do they make a promise of delivery.

Additionally, each node applies the node, service and tag filters locally before
storing the event. This means the events at each agent may be different
depending on their configuration.

This endpoint does allow for filtering on events by name by providing
the `name` query parameter.

Lastly, to support [watches](/docs/agent/watches.html), this endpoint supports
blocking queries. However, the semantics of this endpoint are slightly
different. Most blocking queries provide a monotonic index, and block until a
newer index is available. This can be supported as a consequence of the total
ordering of the [consensus protocol](/docs/internals/consensus.html). With
gossip, there is no ordering, and instead `X-Consul-Index` maps to the newest
event that matches the query.

In practice, this means the index is only useful when used against a single
agent, and has no meaning globally. Because Consul defines the index as being
opaque, clients should not be expecting a natural ordering either.

Lastly, agents only buffer the most recent entries. The number of entries should
not be depended upon, but currently defaults to 256. This value could change in
the future. The buffer should be large enough for most clients and watches.

+ Parameters
    + name (optional, string) ... event to return

+ Response 200 (application/json)
    + Headers
    
            X-Consul-Index: 1

    + Body

            [
                {
                    "ID": "b54fe110-7af5-cafc-d1fb-afc8ba432b1c",
                    "Name": "deploy",
                    "Payload": "MTYwOTAzMA==",
                    "NodeFilter": "",
                    "ServiceFilter": "",
                    "TagFilter": "",
                    "Version": 1,
                    "LTime": 19
                },
                ...
            ]

# Group Status

The Status endpoints are used to get information about the status of the Consul
cluster. These are generally very low level, and not really useful for clients.

## Leader [/v1/status/leader]

### Retrieve Raft leader [GET]

Returns the Raft leader for the datacenter the agent is running in.

+ Response 200 (application/json)
    + Body
    
            "10.1.10.12:8300"

## Peers [/v1/status/peers]

### Returns Raft peer set [GET]

Returns the Raft peers for the datacenter the agent is running in.

+ Response 200 (application/json)
    + Body

            [
                "10.1.10.12:8300",
                "10.1.10.11:8300",
                "10.1.10.10:8300"
            ]
